# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'CameraStreamTest.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


#To do...
# Add opencv stuff (pose detection, drawing on image, etc)
# Add system text under image (connecting camera, values updated, etc)


#credits:
#pyqt, pyqt-tools
#this guy for displaying opencv: https://gist.github.com/docPhil99/ca4da12c9d6f29b9cea137b617c7b8b1
#This article for fixing displaying open:  https://medium.com/@ilias.info.tel/display-opencv-camera-on-a-pyqt-app-4465398546f7

from PyQt5 import QtCore, QtWidgets
from PyQt5.QtGui import QPixmap, QColor
from PyQt5.QtGui import QImage,QPixmap
from PyQt5.QtCore import pyqtSignal as Signal,pyqtSlot as Slot
import serial.tools.list_ports
import serial
from appFiles.timedComs import ArduinoTimedComs as ArdComs
from appFiles.cameraThread import ImagingThread
from appFiles.projectileMotion import ProjectileMotion
import matplotlib.pyplot as plt
import appFiles.arduinoCommands as AC
import json
import time

#Toggle debug here to send debug messages to serial
DEBUG = True

#Default / Customisable variables
arduinoBaudRate = 115200
WINDOW_NAME = "Sam's Masters Project"
FLIP_Y_MOTION = True
FLIP_X_MOTION = False
#Multipliers for angle motion (FOR TESTING ONLY - SET PERMANENT IN SYSTEM C CODE)
ANGLE_CORRECTION_UPPER = 1
ANGLE_CORRECTION_LOWER = 1


#subclass of QLabel to allow gathering of mouse cursor position from clicks
class ClickableLabel(QtWidgets.QLabel):
    clicked = Signal(list)
    def __init__(self, parent=None):
        super().__init__(parent)
    
    #Overwrite of parent QLabels function
    def mousePressEvent(self, event):
        x,y = event.x(), event.y()
        self.clicked.emit([x,y])
        

class MyApp(QtWidgets.QMainWindow):
    runCamera = False
    jsonDir = 'appFiles/defaultData.json'
    projectileTypes = ["Cylinder", "Sphere"]
    projectileDict = {
        'Radius' : 10,
        'Mass' : 0.04,
        'InitialVelocity' : 5,
        'TimeStep' : 0.01,
        'DragCoefficient' : 0.5
    }
    settingsDict = {
        'CameraNum' : 0,
        'COMPORT' : None,
        'ProjectileInfo' : projectileDict
    }

    def __init__(self):
        #init Qt window
        super().__init__()
        #class variables
        self.poseResults = None
        self.ardSerial = None
        self.xMinAngle = 1
        self.yMinAngle = 1
        self.xMotion = False
        self.yMotion = False
        self.OOBangleLow = -35
        self.OOBangleHigh = 35
        self.lowerAngleHold = 0
        self.upperResetAngle = 0
        self.upperAngleHold = self.upperResetAngle
        self.upperRotDown = True
        self.upperAngleLim = 45
        self.lidarVal = 0
        self.awaitingLidar = False
        self.projMotion = ProjectileMotion()
        #setup window
        self.readDefaultsJson()
        self.updateProjectileSettings()
        self.setupUi()
        self.show()

    def setupUi(self):

        #Main Window setup
        self.setObjectName(WINDOW_NAME)
        self.resize(597, 613)
        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setObjectName("verticalLayout_2")

        #Tabs setup
        #---MAIN TAB
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setObjectName("tabWidget")
        self.MainTab = QtWidgets.QWidget()
        self.MainTab.setObjectName("MainTab")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.MainTab)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.splitter = QtWidgets.QSplitter(self.MainTab)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.gridLayoutWidget = QtWidgets.QWidget(self.splitter)
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        #Left side vertical button layout
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.gridLayoutWidget)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        #place camera button
        self.ConnectCameraButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ConnectCameraButton.setObjectName("ConnectCameraButton")
        self.verticalLayout_3.addWidget(self.ConnectCameraButton)
        #place arduino connect button
        self.ConnectArduinoButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ConnectArduinoButton.setObjectName("ConnectArduinoButton")
        self.verticalLayout_3.addWidget(self.ConnectArduinoButton)
        #place toggle tracking button
        self.ToggleTrackingButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ToggleTrackingButton.setObjectName("ToggleTracking")
        self.verticalLayout_3.addWidget(self.ToggleTrackingButton)
        #place fire projectile button
        self.FireProjectButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.FireProjectButton.setObjectName("FireProjectButton")
        self.verticalLayout_3.addWidget(self.FireProjectButton)
        #Place show trajectory button
        self.ShowTrajectoryButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ShowTrajectoryButton.setObjectName("ShowTrajectoryButton")
        self.verticalLayout_3.addWidget(self.ShowTrajectoryButton)
        #Place get lidar button
        self.GetLidarButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.GetLidarButton.setObjectName("GetLidarButton")
        self.verticalLayout_3.addWidget(self.GetLidarButton)
        #horizontal separation
        self.horizontalLayout.addWidget(self.splitter)
        #image label
        self.imageLabel = ClickableLabel(self.splitter)
        self.imageLabel.setMinimumSize(QtCore.QSize(ImagingThread.imageWidthResized, ImagingThread.imageHeightResized))
        self.imageLabel.setObjectName("ImageView")
        self.horizontalLayout.addWidget(self.splitter)
        #define as main tab
        self.tabWidget.addTab(self.MainTab, "")


        #---Settings Tab
        self.SettingsTab = QtWidgets.QWidget()
        self.SettingsTab.setObjectName("SettingsTab")
        self.gridLayout = QtWidgets.QGridLayout(self.SettingsTab)
        self.gridLayout.setObjectName("gridLayout")
        #Camera Number Label + LineEdit
        self.CameraNumberLabel = QtWidgets.QLabel(self.SettingsTab)
        self.CameraNumberLabel.setObjectName("CameraNumberLabel")
        self.gridLayout.addWidget(self.CameraNumberLabel, 0, 0, 1, 1)
        self.CameraNumberLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.CameraNumberLE.setObjectName("CameraNumberLE")
        self.gridLayout.addWidget(self.CameraNumberLE, 0, 2, 1, 1)
        #COM PORT Label + LineEdit
        self.ComPortLabel = QtWidgets.QLabel(self.SettingsTab)
        self.ComPortLabel.setObjectName("ComPortLabel")
        self.gridLayout.addWidget(self.ComPortLabel, 1, 0, 1, 1)
        self.ComPortCombo = QtWidgets.QComboBox(self.SettingsTab)
        self.ComPortCombo.setObjectName("ComPortCombo")
        self.gridLayout.addWidget(self.ComPortCombo, 1, 2, 1, 1)
        self.refreshComButton = QtWidgets.QPushButton(self.SettingsTab)
        self.refreshComButton.setObjectName("Refresh COM Ports")
        self.gridLayout.addWidget(self.refreshComButton, 1, 3, 1, 1)
        #Projectile Radius Label + LineEdit
        self.RadiusLabel = QtWidgets.QLabel(self.SettingsTab)
        self.RadiusLabel.setObjectName("RadiusLabel")
        self.gridLayout.addWidget(self.RadiusLabel, 2, 0, 1, 1)
        self.RadiusLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.RadiusLE.setObjectName("RadiusLE")
        self.gridLayout.addWidget(self.RadiusLE, 2, 1, 1, 2)
        #Projectile Mass Label + LineEdit
        self.MassLabel = QtWidgets.QLabel(self.SettingsTab)
        self.MassLabel.setObjectName("MassLabel")
        self.gridLayout.addWidget(self.MassLabel, 3, 0, 1, 1)
        self.MassLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.MassLE.setObjectName("MassLE")
        self.gridLayout.addWidget(self.MassLE, 3, 1, 1, 2)
        #Initial Velocity Label + LineEdit
        self.InitVelLabel = QtWidgets.QLabel(self.SettingsTab)
        self.InitVelLabel.setObjectName("InitVelLabel")
        self.gridLayout.addWidget(self.InitVelLabel,4, 0, 1, 1)
        self.InitVelLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.InitVelLE.setObjectName("InitVelLE")
        self.gridLayout.addWidget(self.InitVelLE,4, 1, 1, 2)   
        #Time Step Label + LineEdit
        self.TimeStepLabel = QtWidgets.QLabel(self.SettingsTab)
        self.TimeStepLabel.setObjectName("TimeStepLabel")
        self.gridLayout.addWidget(self.TimeStepLabel,5, 0, 1, 1)
        self.TimeStepLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.TimeStepLE.setObjectName("TimeStepLE")
        self.gridLayout.addWidget(self.TimeStepLE,5, 1, 1, 2)    
        #Drag Coefficient Label + LineEdit
        self.DragCoLabel = QtWidgets.QLabel(self.SettingsTab)
        self.DragCoLabel.setObjectName("DragCoLabel")
        self.gridLayout.addWidget(self.DragCoLabel,6, 0, 1, 1)
        self.DragCoLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.DragCoLE.setObjectName("DragCoLE")
        self.gridLayout.addWidget(self.DragCoLE,6, 1, 1, 2)     
        #Apply Setting Button
        self.ApplySettings = QtWidgets.QPushButton(self.SettingsTab)
        self.ApplySettings.setObjectName("ApplySettings")
        self.gridLayout.addWidget(self.ApplySettings, 6, 3, 1, 1)
        self.tabWidget.addTab(self.SettingsTab, "")
        self.verticalLayout_2.addWidget(self.tabWidget)
        
        #-----------------terminal scroller
        self.TerminalScroller = QtWidgets.QTextEdit(self.centralwidget)
        self.TerminalScroller.setMinimumSize(QtCore.QSize(0, 100))
        self.TerminalScroller.setObjectName("TerminalScroller")
        self.TerminalScroller.setReadOnly(True)
        self.verticalLayout_2.addWidget(self.TerminalScroller)

        #-------------------MENU BAR
        self.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 597, 26))
        self.menubar.setObjectName("menubar")
        self.setMenuBar(self.menubar)
        #-----------------status bar
        self.angleStatusBar = QtWidgets.QStatusBar(self)
        self.angleStatusBar.setObjectName("AngleStatusbar")
        self.angleLabel = QtWidgets.QLabel(f"Upper Angle: {self.upperAngleHold}")
        self.angleStatusBar.addPermanentWidget(self.angleLabel)
        self.setStatusBar(self.angleStatusBar)

        #Signal functions
        self.ConnectCameraButton.clicked.connect(self.toggleCamera)
        self.ConnectArduinoButton.clicked.connect(self.connectArduinoFunc)
        self.ToggleTrackingButton.clicked.connect(self.toggleTrackingFunc)
        self.FireProjectButton.clicked.connect(self.fireProjectButtonFunc)
        self.ApplySettings.clicked.connect(self.applySettingsFunc)
        self.refreshComButton.clicked.connect(self.updateComCombo)
        self.imageLabel.clicked.connect(self.imageClickFunc)
        self.ShowTrajectoryButton.clicked.connect(self.showTrajectoryFunc)
        self.GetLidarButton.clicked.connect(self.getLidarFunc)

        #setup Combo lists
        self.updateComCombo()

        #Button / Field variables
        self.cameraConnected = False
        self.projectileFiring = False
        self.arduinoConnected = False
        self.tracking = False
        self.trackingInMotion = False #variable is used to stop tracking function being called multiple times at once

        #Threading
        #Arduino comms thread
        self.ardCom = ArdComs(self.recieveArdComs, debugFunc = self.terminalDebugger)

        #Camera Thread
        self.cameraThread = ImagingThread()
        self.cameraThread.frame_signal.connect(self.setImage)

        #set blank image 
        grey = QPixmap(ImagingThread.imageWidthResized, ImagingThread.imageHeightResized)
        grey.fill(QColor('darkGray'))
        # set the image image to the grey pixmap
        self.imageLabel.setPixmap(grey)

        #Set text fields, ect
        self.retranslateUi()
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(self)

        #Init message
        self.TerminalScroller.append("Window Booted")


    def showTrajectoryFunc(self):
        xyArray = self.projMotion.getDragMotion()[0]
        xyNoDragA = self.projMotion.getNoDragMotion()[0]
        plt.plot(xyArray[:,0], xyArray[:,1], marker='o', label='Drag')     # line + optional markers
        plt.plot(xyNoDragA[:,0], xyNoDragA[:,1], marker='x', label='No Drag')     # line + optional markers
        plt.legend()
        plt.xlabel('x (m)')
        plt.ylabel('y (m)')
        plt.title('Object trajectory')
        plt.axis('equal')              # equal aspect ratio so 1 m in x = 1 m in y
        plt.grid(True)
        plt.show()


    ##--------------------------------UI FUNCTIONS

    #Func to set texts of all labels, buttons, etc
    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate(WINDOW_NAME, WINDOW_NAME))
        self.ConnectCameraButton.setText(_translate(WINDOW_NAME, "Connect Camera"))
        self.ConnectArduinoButton.setText(_translate(WINDOW_NAME, "Connect Arduino"))
        self.FireProjectButton.setText(_translate(WINDOW_NAME, "Fire Projectile"))
        self.ToggleTrackingButton.setText(_translate("MainWindow", "Toggle Tracking"))
        self.ShowTrajectoryButton.setText(_translate(WINDOW_NAME, "Show Trajectory"))
        self.GetLidarButton.setText(_translate(WINDOW_NAME, "Get Distance"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.MainTab), _translate(WINDOW_NAME, "Main"))
        self.CameraNumberLabel.setText(_translate(WINDOW_NAME, "Camera Number: "))
        self.ComPortLabel.setText(_translate(WINDOW_NAME, "System COM Port"))
        self.refreshComButton.setText(_translate(WINDOW_NAME, "Refresh"))
        self.ApplySettings.setText(_translate(WINDOW_NAME, "Apply"))
        self.RadiusLabel.setText(_translate(WINDOW_NAME, "Radius [m]"))
        self.MassLabel.setText(_translate(WINDOW_NAME, "Mass [kg]"))
        self.InitVelLabel.setText(_translate(WINDOW_NAME, "Initial Velocity [m/s]"))
        self.TimeStepLabel.setText(_translate(WINDOW_NAME, "Time Set [s]"))
        self.DragCoLabel.setText(_translate(WINDOW_NAME, "Drag Coefficient"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.SettingsTab), _translate(WINDOW_NAME, "Settings"))
        #Set current values of Line edits
        self.CameraNumberLE.setText(str(MyApp.settingsDict['CameraNum']))
        self.RadiusLE.setText(str(MyApp.settingsDict['ProjectileInfo']['Radius']))
        self.MassLE.setText(str(MyApp.settingsDict['ProjectileInfo']['Mass']))
        self.InitVelLE.setText(str(MyApp.settingsDict['ProjectileInfo']['InitialVelocity']))
        self.TimeStepLE.setText(str(MyApp.settingsDict['ProjectileInfo']['TimeStep']))
        self.DragCoLE.setText(str(MyApp.settingsDict['ProjectileInfo']['DragCoefficient']))
        #set current values of combo boxes
        if MyApp.settingsDict['COMPORT'] in self.COMPORTS.values():
            self.ComPortCombo.setCurrentIndex(list(self.COMPORTS.values()).index(MyApp.settingsDict['COMPORT']))

    #Print debug messages to app terminak
    def terminalDebugger(self, message : str):
        self.TerminalScroller.append(message)

    #update angle status bar value
    def updateAngleStatus(self):
        self.angleLabel.setText(f"Upper Angle: {self.upperAngleHold}")

    #Set image, called on internal signal interrupt
    @Slot(QImage)
    def setImage(self,image):
        self.poseResults = self.cameraThread.getResults()
        self.imageLabel.setPixmap(QPixmap.fromImage(image))
        #if tracking is enabled, update motor position each new image 
        if self.tracking and not self.trackingInMotion:
            self.track()

    #Interrupt upon clicking image
    def imageClickFunc(self, mouseXY):
        if self.cameraConnected:
            anglesXY = ImagingThread.pxToAngle(mouseXY)
            self.TerminalScroller.append(f"Mouse Clicked at: {mouseXY}")
            self.TerminalScroller.append(f"Moving x: {anglesXY[0]}deg, Moving y: {anglesXY[1]}deg...")
            self.moveMotorX(anglesXY[0])
            self.moveMotorY(anglesXY[1])

    #connect arduino button
    def connectArduinoFunc(self):
        if not self.arduinoConnected:
            self.TerminalScroller.append("Attempting Arduino Serial Connection...")
            try:
                self.terminalDebugger("Please Wait... System Booting...")
                self.startArduinoComms()
                self.ConnectArduinoButton.setText(QtCore.QCoreApplication.translate("self", "Disconnect Arduino"))
                self.arduinoConnected = True
                #wake arduino
                time.sleep(0.1)
                self.ardCom.wakeArduino()
                self.TerminalScroller.append(f"Arduino Connected Successfully!")
            except Exception as e:
                self.TerminalScroller.append(f"Failed to Connect Arduino!! \nError: {e}")
        else:
            self.TerminalScroller.append("Disconnecting Arduino Serial Connection...")
            try: 
                self.stopArduinoComs()
                self.TerminalScroller.append(f"Arduino disconnected!")
                self.ConnectArduinoButton.setText(QtCore.QCoreApplication.translate("self", "Connect Arduino"))
                self.arduinoConnected = False
            except Exception as e:
                self.TerminalScroller.append(f"Failed to disconnect Arduino!! \nError: {e}")
        ##Arduino connected begin physical setup
        self.upperAngleHold = self.upperResetAngle
        ##update status bar
        self.updateAngleStatus()

    #refresh the communication connections combo box
    def updateComCombo(self):
        #get all connected comports
        self.COMPORTS = {}
        comportInfoList = serial.tools.list_ports.comports()
        for comportInfo in comportInfoList:
            self.COMPORTS[comportInfo.description] = comportInfo.name
        #clear existings combo items and add new
        self.ComPortCombo.clear()
        for key,_ in list(self.COMPORTS.items()):
            self.ComPortCombo.addItem(key)

    #Update variables used for projectile settings calculations
    def updateProjectileSettings(self):
        self.projMotion.projectileRad = self.settingsDict['ProjectileInfo']['Radius']
        self.projMotion.projectileMass = self.settingsDict['ProjectileInfo']['Mass']
        self.projMotion.initialVelocity = self.settingsDict['ProjectileInfo']['InitialVelocity']
        self.projMotion.timeStep = self.settingsDict['ProjectileInfo']['TimeStep']
        self.projMotion.dragCoefficient = self.settingsDict['ProjectileInfo']['DragCoefficient']

    def isNumber(self, val):
        try:
            float(val)
            return True
        except Exception:
            return False

    #Apply settings as currently written in settings tab
    def applySettingsFunc(self):
        #####HARDWARE SETTINGS
        #Get camera Number (only accepts number if entry is all digits)
        holdval = self.CameraNumberLE.text()
        if not any(not char.isdigit() for char in holdval) and len(holdval) > 0:
            MyApp.settingsDict['CameraNum'] = int(holdval)
        self.CameraNumberLE.setText(holdval)
        #Set arduino comport
        MyApp.settingsDict['COMPORT'] = self.COMPORTS[self.ComPortCombo.currentText()]
        #####PROJECTILE SETTINGS
        projectileLEs = [self.RadiusLE, self.MassLE, self.InitVelLE, self.TimeStepLE, self.DragCoLE]
        keys = list(MyApp.settingsDict['ProjectileInfo'].keys())
        for indx, key in enumerate(keys):
            holdVal = projectileLEs[indx].text()
            if self.isNumber(holdVal) and len(holdVal) > 0:
                MyApp.settingsDict['ProjectileInfo'][key] = float(holdVal)
            projectileLEs[indx].setText(holdVal)
        ###SAVE
        #Update projectile Calculation settings
        self.updateProjectileSettings()
        #Save settings to file
        self.writeDefaultsJson()
        #DEBUG serial output
        self.TerminalScroller.append(f"Settings Applied: {str(MyApp.settingsDict)}")



    #--------JSON Editing

    #Sets initial values from last application
    def readDefaultsJson(self):
        #try open json, may not exist
        try:
            with open(MyApp.jsonDir) as defaultsJson:
                jsonStr = defaultsJson.read()
        except Exception as e:
            print(f"Failed reading defaults Json: {e}") 
            return None
        #interpret json as python dict and use it to replace app settings
        MyApp.settingsDict = json.loads(jsonStr)
        return None
    
    #write applied settings to a json file
    def writeDefaultsJson(self):
        #write settings dict to a json file
        with open(MyApp.jsonDir, "w") as jsonFile:
            jsonFile.write(json.dumps(MyApp.settingsDict))



    #------ARDUINO COMMUNICATION

    #Setup arduino serial communication
    def startArduinoComms(self):
        self.ardCom.connect(self.settingsDict['COMPORT'], arduinoBaudRate)

    #stop arduino serial communication
    def stopArduinoComs(self):
        self.ardCom.disconnect()
    
    #Send a message to arduino over serial
    def messageArduino(self, command, value):
        self.ardCom.message(command, value)

    #Interrupt for calling on arduino communication recieval
    def recieveArdComs(self, message : list):
        command = message[0]
        value = message[1]
        if command == AC.COMMAND_MOVE_LOWER:
            self.xMotion = False
        elif command == AC.COMMAND_MOVE_UPPER:
            self.yMotion = False
        elif command == AC.COMMAND_LIDAR:
            self.awaitingLidar = False
            self.lidarVal = value
            self.terminalDebugger(f"LIDAR RECIEVED: {value}mm")
        elif command == AC.COMMAND_UPPER_OOB:
            self.terminalDebugger(f"UPPER Out Of Bounds!")
            if self.upperRotDown:
                self.upperAngleHold = self.OOBangleLow
            else:
                self.upperAngleHold = self.OOBangleHigh
        elif command == AC.COMMAND_LOWER_OOB:
            self.terminalDebugger(f"LOWER Out Of Bounds!")
        #Update angle status (most commands need this )
        self.updateAngleStatus()

    #--------------------PHYSICAL ACTION COMMANDS


    #toggle tracking on/off
    def toggleTrackingFunc(self):
        if not self.tracking:
            self.TerminalScroller.append("Starting Tracking")
            self.ToggleTrackingButton.setText(QtCore.QCoreApplication.translate("self", "Stop Tracking"))
            self.tracking = True
        else:
            self.TerminalScroller.append("Stopping Tracking")
            self.ToggleTrackingButton.setText(QtCore.QCoreApplication.translate("self", "Start Tracking"))
            self.tracking = False         

    #send fire projectile command to arduino
    def fireProjectButtonFunc(self):
        self.TerminalScroller.append("Firing Projectile!")
        ###...
        #Need to create full firing calculator, should
        #request ir distance, waiting for reply
        #calculate trigonmetry
        #calculate drag
        #move upwards in accordance to drag, trig, etc to hit currently facing target
        #fire projectile
        self.messageArduino(AC.COMMAND_FIRE, 6)

    #Simply shoots projectile, no compensation
    def fireProjectileBasic(self):
        self.TerminalScroller.append("Firing Projectile!")
        self.messageArduino(AC.COMMAND_FIRE, 6)

    #Calculates projectile motion without drag then fires
    def fireProjectileNoDrag(self):
        #Disable tracking
        self.tracking = False
        #Get IR Distance
        self.getLidarFunc()
        self.awaitingLidar = True
        while self.awaitingLidar:
            time.sleep(0.1) #wait for lidar
        #Update projectile motion calculator
        requiredAngle, _ = self.projMotion.calculateAngle(self.lidarVal/1000, self.upperAngleHold, False)
        requiredMotion = requiredAngle - self.upperAngleHold
        #Move required amount
        self.moveMotorY(requiredMotion)
        #Fire projectile
        self.TerminalScroller.append("Firing Projectile!")
        self.messageArduino(AC.COMMAND_FIRE, 6)
        #Show trajectory esimation
        self.projMotion.launchDegrees = requiredAngle
        self.projMotion.plotMPL(self.projMotion.getNoDragMotion()[0], targetDistance=self.lidarVal, targetAngle = requiredAngle)

    #calculates projectile motion with drag then fires
    def fireProjectileDrag(self):
        #Disable tracking
        self.tracking = False
        #Get IR Distance
        self.getLidarFunc()
        self.awaitingLidar = True
        while self.awaitingLidar:
            time.sleep(0.1) #wait for lidar
        #Update projectile motion calculator
        requiredAngle, _ = self.projMotion.calculateAngle(self.lidarVal/1000, self.upperAngleHold, True)
        requiredMotion = requiredAngle - self.upperAngleHold
        #Move required amount
        self.moveMotorY(requiredMotion)
        #Fire projectile
        self.TerminalScroller.append("Firing Projectile!")
        self.messageArduino(AC.COMMAND_FIRE, 6)
        #Show trajectory esimation
        self.projMotion.launchDegrees = requiredAngle
        self.projMotion.plotMPL(self.projMotion.getDragMotion()[0], targetDistance=self.lidarVal, targetAngle = requiredAngle)


    #Retrieve current lidar distance from arduino
    def getLidarFunc(self):
        self.terminalDebugger("Retrieving Current Lidar...")
        self.awaitingLidar = True
        self.messageArduino(AC.COMMAND_LIDAR,0)

    #send motor x movement command to arduino
    def moveMotorX(self, angle):
        #Dont send signal if already in / awaiting motion
        if self.xMotion:
            return
        #flip direction if required
        if FLIP_X_MOTION:
            angle = angle * -1
        #Apply angle correction multiplier
        angle = angle * ANGLE_CORRECTION_LOWER
        #Send arduino command
        ret = self.messageArduino(AC.COMMAND_MOVE_LOWER, int(angle / AC.DEG_DECIMAL_SHIFT))
        self.xMotion = True #Flag motors in motion
        ##DEBUG LOWER ANGLE
        # self.lowerAngleHold += angle
        # print(f"Lower Angle: {self.lowerAngleHold}")

    def moveMotorY(self, angle):
        #Dont send signal if already in / awaiting motion
        if self.yMotion:
            return
        #Flip direction if required
        if FLIP_Y_MOTION:
            angle = angle * -1
        #flag clockwise or counter cw
        self.upperRotDown = angle < 0
        #Apply angle correction multiplier
        angle = angle * ANGLE_CORRECTION_UPPER
        #send arduino command
        ret = self.messageArduino(AC.COMMAND_MOVE_UPPER, int(angle / AC.DEG_DECIMAL_SHIFT))
        self.yMotion = True #flag motors in motion
        #Update current angle position
        self.upperAngleHold = self.upperAngleHold + angle
        self.updateAngleStatus()

        
    #Called upon each new image when tracking is enabled
    def track(self):
        #Set tracking in motion to say function is occupied
        self.trackingInMotion = True
        #only move if angle is big enough to stop constant tiny adjustments
        xyPixels = self.cameraThread.getPartPixels("Nose")
        if xyPixels is not None:
            xyAngles = self.cameraThread.pxToAngle(xyPixels)
            if (xyAngles[0] * xyAngles[0]) > self.xMinAngle:
                self.moveMotorX(xyAngles[0])
            if (xyAngles[1] * xyAngles[1]) > self.yMinAngle:
                self.moveMotorY(xyAngles[1])
        #Turn off tracking in motion to allow next track command
        self.trackingInMotion = False



    #-----------------Camera Functions
    #Connect to camera, begin image recording and viewing
    def connectCamera(self):
        self.TerminalScroller.append("Connecting To Camera, May Take few Seconds...")
        self.cameraConnected = True
        ImagingThread.cameraNum = self.settingsDict['CameraNum']
        ImagingThread.running = True
        self.cameraThread.start()

    #disconnect camera, stop viewing
    def disconnectCamera(self):
        ImagingThread.running = False
        self.cameraConnected = False
        self.TerminalScroller.append("Disconnecting Camera")

    #toggle camera on/off (wrapper for connectCamera / disconnectCamera)
    def toggleCamera(self):        
        if not self.cameraConnected:
            self.connectCamera()
            self.ConnectCameraButton.setText(QtCore.QCoreApplication.translate("self", "Disconnect Camera"))
        else:
            self.disconnectCamera()
            self.ConnectCameraButton.setText(QtCore.QCoreApplication.translate("self", "Connect Camera"))




if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication([])
    ui = MyApp()
    sys.exit(app.exec_())
