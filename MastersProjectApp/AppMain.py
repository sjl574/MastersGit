# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'CameraStreamTest.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


#To do...
# Add opencv stuff (pose detection, drawing on image, etc)
# Add system text under image (connecting camera, values updated, etc)


#credits:
#pyqt, pyqt-tools
#this guy for displaying opencv: https://gist.github.com/docPhil99/ca4da12c9d6f29b9cea137b617c7b8b1
#This article for fixing displaying open:  https://medium.com/@ilias.info.tel/display-opencv-camera-on-a-pyqt-app-4465398546f7


from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtGui import QPixmap, QColor
from PyQt5.QtGui import QImage,QPixmap
from PyQt5.QtCore import QThread,pyqtSignal as Signal,pyqtSlot as Slot
import serial.tools.list_ports
import serial
import cv2 as cv
import numpy as np
from appFiles.poseDetector import detector
import appFiles.arduinoCommands as AC
import time
import json

#Toggle debug here to send debug messages to serial
DEBUG = True

#Default / Customisable variables
arduinoBaudRate = 115200
WINDOW_NAME = "Sam's Masters Project"
FLIP_Y_MOTION = True
FLIP_X_MOTION = False


#subclass of QLabel to allow gathering of mouse cursor position from clicks
class ClickableLabel(QtWidgets.QLabel):
    clicked = Signal(list)
    def __init__(self, parent=None):
        super().__init__(parent)
    
    #Overwrite of parent QLabels function
    def mousePressEvent(self, event):
        x,y = event.x(), event.y()
        self.clicked.emit([x,y])
        


class MyApp(QtWidgets.QMainWindow):
    runCamera = False
    jsonDir = 'appFiles/defaultData.json'
    projectileTypes = ["Cylinder", "Sphere"]
    settingsDict = {
        'CameraNum' : 0,
        'COMPORT' : None,
        'ProjectileType' : 'Cylinder',
        'ProjectileRadius' : 10,
        'ProjectileLength' : 30,
    }

    def __init__(self):
        #init Qt window
        super().__init__()
        #class variables
        self.poseResults = None
        self.ardSerial = None
        self.xMinAngle = 1
        self.yMinAngle = 1
        #setup window
        self.readDefaultsJson()
        self.setupUi()
        self.show()

    def setupUi(self):

        #Main Window setup
        self.setObjectName(WINDOW_NAME)
        self.resize(597, 613)
        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setObjectName("verticalLayout_2")

        #Tabs setup
        #---MAIN TAB
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setObjectName("tabWidget")
        self.MainTab = QtWidgets.QWidget()
        self.MainTab.setObjectName("MainTab")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.MainTab)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.splitter = QtWidgets.QSplitter(self.MainTab)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.gridLayoutWidget = QtWidgets.QWidget(self.splitter)
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        #Left side vertical button layout
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.gridLayoutWidget)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        #place camera button
        self.ConnectCameraButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ConnectCameraButton.setObjectName("ConnectCameraButton")
        self.verticalLayout_3.addWidget(self.ConnectCameraButton)
        #place arduino connect button
        self.ConnectArduinoButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ConnectArduinoButton.setObjectName("ConnectArduinoButton")
        self.verticalLayout_3.addWidget(self.ConnectArduinoButton)
        #place toggle tracking button
        self.ToggleTrackingButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.ToggleTrackingButton.setObjectName("ToggleTracking")
        self.verticalLayout_3.addWidget(self.ToggleTrackingButton)
        #place fire projectile button
        self.FireProjectButton = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.FireProjectButton.setObjectName("FireProjectButton")
        self.verticalLayout_3.addWidget(self.FireProjectButton)
        #horizontal seperation
        self.horizontalLayout.addWidget(self.splitter)
        #image label
        self.imageLabel = ClickableLabel(self.splitter)
        self.imageLabel.setMinimumSize(QtCore.QSize(ImagingThread.imageWidthResized, ImagingThread.imageHeightResized))
        self.imageLabel.setObjectName("ImageView")
        self.horizontalLayout.addWidget(self.splitter)
        #define as main tab
        self.tabWidget.addTab(self.MainTab, "")


        #---Settings Tab
        self.SettingsTab = QtWidgets.QWidget()
        self.SettingsTab.setObjectName("SettingsTab")
        self.gridLayout = QtWidgets.QGridLayout(self.SettingsTab)
        self.gridLayout.setObjectName("gridLayout")
        self.ComPortCombo = QtWidgets.QComboBox(self.SettingsTab)
        self.ComPortCombo.setObjectName("ComPortCombo")
        self.gridLayout.addWidget(self.ComPortCombo, 1, 2, 1, 1)
        self.CameraNumberLabel = QtWidgets.QLabel(self.SettingsTab)
        self.CameraNumberLabel.setObjectName("CameraNumberLabel")
        self.gridLayout.addWidget(self.CameraNumberLabel, 0, 0, 1, 1)
        self.ComPortLabel = QtWidgets.QLabel(self.SettingsTab)
        self.ComPortLabel.setObjectName("ComPortLabel")
        self.gridLayout.addWidget(self.ComPortLabel, 1, 0, 1, 1)
        self.ApplySettings = QtWidgets.QPushButton(self.SettingsTab)
        self.ApplySettings.setObjectName("ApplySettings")
        self.gridLayout.addWidget(self.ApplySettings, 3, 3, 1, 1)
        self.CameraNumberLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.CameraNumberLE.setObjectName("CameraNumberLE")
        self.gridLayout.addWidget(self.CameraNumberLE, 0, 2, 1, 1)
        self.DimensionsLabel = QtWidgets.QLabel(self.SettingsTab)
        self.DimensionsLabel.setObjectName("DimensionsLabel")
        self.gridLayout.addWidget(self.DimensionsLabel, 2, 0, 1, 2)
        self.gridLayout_2 = QtWidgets.QGridLayout()
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.ProjectileLengthLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.ProjectileLengthLE.setObjectName("ProjectileLengthLE")
        self.gridLayout_2.addWidget(self.ProjectileLengthLE, 1, 2, 1, 1)
        self.ProjectileTypeCombo = QtWidgets.QComboBox(self.SettingsTab)
        self.ProjectileTypeCombo.setObjectName("ProjectileTypeCombo")
        self.gridLayout_2.addWidget(self.ProjectileTypeCombo, 0, 0, 2, 1)
        self.ProjectileRadiusLE = QtWidgets.QLineEdit(self.SettingsTab)
        self.ProjectileRadiusLE.setObjectName("ProjectileRadiusLE")
        self.gridLayout_2.addWidget(self.ProjectileRadiusLE, 0, 2, 1, 1)
        self.RadiusLabel = QtWidgets.QLabel(self.SettingsTab)
        self.RadiusLabel.setObjectName("RadiusLabel")
        self.gridLayout_2.addWidget(self.RadiusLabel, 0, 1, 1, 1)
        self.LengthLabel = QtWidgets.QLabel(self.SettingsTab)
        self.LengthLabel.setObjectName("LengthLabel")
        self.gridLayout_2.addWidget(self.LengthLabel, 1, 1, 1, 1)
        self.gridLayout.addLayout(self.gridLayout_2, 2, 2, 1, 1)
        self.refreshComButton = QtWidgets.QPushButton(self.SettingsTab)
        self.refreshComButton.setObjectName("Refresh COM Ports")
        self.gridLayout.addWidget(self.refreshComButton, 1, 3, 1, 1)
        self.tabWidget.addTab(self.SettingsTab, "")
        self.verticalLayout_2.addWidget(self.tabWidget)
        
        #-----------------terminal scroller
        self.TerminalScroller = QtWidgets.QTextEdit(self.centralwidget)
        self.TerminalScroller.setMinimumSize(QtCore.QSize(0, 100))
        self.TerminalScroller.setObjectName("TerminalScroller")
        self.TerminalScroller.setReadOnly(True)
        self.verticalLayout_2.addWidget(self.TerminalScroller)
        #-------------------MENU BAR
        self.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(self)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 597, 26))
        self.menubar.setObjectName("menubar")
        self.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(self)
        self.statusbar.setObjectName("statusbar")
        self.setStatusBar(self.statusbar)

        #Signal functions
        self.ConnectCameraButton.clicked.connect(self.toggleCamera)
        self.ConnectArduinoButton.clicked.connect(self.connectArduinoFunc)
        self.ToggleTrackingButton.clicked.connect(self.toggleTrackingFunc)
        self.FireProjectButton.clicked.connect(self.fireProjectButtonFunc)
        self.ApplySettings.clicked.connect(self.applySettingsFunc)
        self.refreshComButton.clicked.connect(self.updateComCombo)
        self.imageLabel.clicked.connect(self.imageClickFunc)

        #setup Combo lists
        self.ProjectileTypeCombo.addItems(MyApp.projectileTypes)
        self.updateComCombo()

        #Button / Field variables
        self.cameraConnected = False
        self.projectileFiring = False
        self.COMPORT = ""
        self.projectileRadius = 0
        self.projectileLength = 0
        self.projectileType = "Cylinder"
        self.arduinoConnected = False
        self.tracking = False
        self.trackingInMotion = False #variable is used to stop tracking function being called multiple times at once

        #Threading (for camera)
        self.cameraThread = ImagingThread()
        #Attach signal from camera thread to apps update image function
        self.cameraThread.frame_signal.connect(self.setImage)

        #set blank image 
        grey = QPixmap(ImagingThread.imageWidthResized, ImagingThread.imageHeightResized)
        grey.fill(QColor('darkGray'))
        # set the image image to the grey pixmap
        self.imageLabel.setPixmap(grey)

        #Set text fields, ect
        self.retranslateUi()
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(self)

        #Init message
        self.TerminalScroller.append("Window Booted")


    #Func to set texts of all labels, buttons, etc
    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate(WINDOW_NAME, WINDOW_NAME))
        self.ConnectCameraButton.setText(_translate(WINDOW_NAME, "Connect Camera"))
        self.ConnectArduinoButton.setText(_translate(WINDOW_NAME, "Connect Arduino"))
        self.FireProjectButton.setText(_translate(WINDOW_NAME, "Fire Projectile"))
        self.ToggleTrackingButton.setText(_translate("MainWindow", "Toggle Tracking"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.MainTab), _translate(WINDOW_NAME, "Main"))
        self.CameraNumberLabel.setText(_translate(WINDOW_NAME, "Camera Number: "))
        self.ComPortLabel.setText(_translate(WINDOW_NAME, "System COM Port"))
        self.refreshComButton.setText(_translate(WINDOW_NAME, "Refresh"))
        self.ApplySettings.setText(_translate(WINDOW_NAME, "Apply"))
        self.DimensionsLabel.setText(_translate(WINDOW_NAME, "Dimensions:"))
        self.RadiusLabel.setText(_translate(WINDOW_NAME, "Radius"))
        self.LengthLabel.setText(_translate(WINDOW_NAME, "Length"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.SettingsTab), _translate(WINDOW_NAME, "Settings"))
        #Set current values of Line edits
        self.CameraNumberLE.setText(str(MyApp.settingsDict['CameraNum']))
        self.ProjectileLengthLE.setText(str(MyApp.settingsDict['ProjectileLength']))
        self.ProjectileRadiusLE.setText(str(MyApp.settingsDict['ProjectileRadius']))
        #set current values of combo boxes
        if MyApp.settingsDict['COMPORT'] in self.COMPORTS.values():
            self.ComPortCombo.setCurrentIndex(list(self.COMPORTS.values()).index(MyApp.settingsDict['COMPORT']))
        self.ProjectileTypeCombo.setCurrentIndex(self.projectileTypes.index(MyApp.settingsDict['ProjectileType']))


    #Sets initial values from last application
    def readDefaultsJson(self):
        #try open json, may not exist
        try:
            with open(MyApp.jsonDir) as defaultsJson:
                jsonStr = defaultsJson.read()
        except Exception as e:
            print(f"Failed reading defaults Json: {e}") 
            return None
        #interpret json as python dict and use it to replace app settings
        MyApp.settingsDict = json.loads(jsonStr)
        return None
    

    #write applied settings to a json file
    def writeDefaultsJson(self):
        #write settings dict to a json file
        with open(MyApp.jsonDir, "w") as jsonFile:
            jsonFile.write(json.dumps(MyApp.settingsDict))


    def toggleCamera(self):        
        if not self.cameraConnected:
            self.TerminalScroller.append("Connecting To Camera, May Take few Seconds...")
            self.cameraConnected = True
            MyApp.runCamera = True
            self.cameraThread.start()
            self.ConnectCameraButton.setText(QtCore.QCoreApplication.translate("self", "Disconnect Camera"))
        else:
            self.TerminalScroller.append("Disconnecting Camera")
            self.cameraConnected = False
            MyApp.runCamera = False
            self.ConnectCameraButton.setText(QtCore.QCoreApplication.translate("self", "Connect Camera"))


    @Slot(QImage)
    def setImage(self,image):
        self.poseResults = self.cameraThread.getResults()
        self.imageLabel.setPixmap(QPixmap.fromImage(image))
        #if tracking is enabled, update motor position each new image 
        if self.tracking and not self.trackingInMotion:
            self.track()

    def imageClickFunc(self, mouseXY):
        if self.cameraConnected:
            anglesXY = ImagingThread.pxToAngle(mouseXY)
            self.TerminalScroller.append(f"Mouse Clicked at: {mouseXY}")
            self.TerminalScroller.append(f"Moving x: {anglesXY[0]}deg, Moving y: {anglesXY[1]}deg...")
            self.moveMotorX(anglesXY[0])
            self.moveMotorY(anglesXY[1])

    #---------------------BUTTON FUNCTIONS
    def connectArduinoFunc(self):
        if not self.arduinoConnected:
            self.TerminalScroller.append("Attempting Arduino Serial Connection...")
            try:
                self.ardSerial = serial.Serial(self.settingsDict['COMPORT'], arduinoBaudRate, timeout = 1, xonxoff=False, rtscts=False, dsrdtr=False)
                self.TerminalScroller.append(f"Arduino Connected Successfully!")
                self.ConnectArduinoButton.setText(QtCore.QCoreApplication.translate("self", "Disconnect Arduino"))
                self.arduinoConnected = True
            except Exception as e:
                self.TerminalScroller.append(f"Failed to Connect Arduino!! \nError: {e}")
        else:
            self.TerminalScroller.append("Disconnecting Arduino Serial Connection...")
            try: 
                self.ardSerial.close()
                self.TerminalScroller.append(f"Arduino disconnected!")
                self.ConnectArduinoButton.setText(QtCore.QCoreApplication.translate("self", "Connect Arduino"))
                self.arduinoConnected = False
            except Exception as e:
                self.TerminalScroller.append(f"Failed to disconnect Arduino!! \nError: {e}")

    def fireProjectButtonFunc(self):
        self.TerminalScroller.append("Firing Projectile!")
        self.fireProjectile()

    def toggleTrackingFunc(self):
        if not self.tracking:
            self.TerminalScroller.append("Starting Tracking")
            self.ToggleTrackingButton.setText(QtCore.QCoreApplication.translate("self", "Stop Tracking"))
            self.tracking = True
        else:
            self.TerminalScroller.append("Stopping Tracking")
            self.ToggleTrackingButton.setText(QtCore.QCoreApplication.translate("self", "Start Tracking"))
            self.tracking = False         

    def updateComCombo(self):
        #get all connected comports
        self.COMPORTS = {}
        comportInfoList = serial.tools.list_ports.comports()
        for comportInfo in comportInfoList:
            self.COMPORTS[comportInfo.description] = comportInfo.name
        #clear existings combo items and add new
        self.ComPortCombo.clear()
        for key,_ in list(self.COMPORTS.items()):
            self.ComPortCombo.addItem(key)


    def applySettingsFunc(self):
        #Get camera Number (only accepts number if entry is all digits)
        holdval = self.CameraNumberLE.text()
        if not any(not char.isdigit() for char in holdval) and len(holdval) > 0:
            MyApp.settingsDict['CameraNum'] = int(holdval)
        self.CameraNumberLE.setText(holdval)
        #Get radius
        holdval = self.ProjectileRadiusLE.text()
        if not any(not char.isdigit() for char in holdval) and len(holdval) > 0:
            MyApp.settingsDict['ProjectileRadius'] = int(holdval)
        self.ProjectileRadiusLE.setText(holdval)
        #Get length
        holdval = self.ProjectileLengthLE.text()
        if not any(not char.isdigit() for char in holdval) and len(holdval) > 0:
            MyApp.settingsDict['ProjectileLength'] = int(holdval)
        self.ProjectileLengthLE.setText(holdval)
        #set Projectile Shape
        MyApp.settingsDict['ProjectileType'] = self.projectileTypes[self.ProjectileTypeCombo.currentIndex()]
        #Set arduino comport
        MyApp.settingsDict['COMPORT'] = self.COMPORTS[self.ComPortCombo.currentText()]
        #Save settings to file
        self.writeDefaultsJson()
        #DEBUG serial output
        self.TerminalScroller.append(f"Settings Applied:")
        self.TerminalScroller.append(f"Camera: {str(MyApp.settingsDict['CameraNum'])}")
        self.TerminalScroller.append(f"Ard Com: {MyApp.settingsDict['COMPORT']}")
        self.TerminalScroller.append(f"Proj Type: {MyApp.settingsDict['ProjectileType']}")
        self.TerminalScroller.append(f"Proj Len: {str(MyApp.settingsDict['ProjectileLength'])}")
        self.TerminalScroller.append(f"Proj Rad: {str(MyApp.settingsDict['ProjectileRadius'])}")


    #Other Functions

    #convert cv image to be readable by qt
    def cvImageToQt(self, image):
        #convert to rgb (cv works in bgr)
        image = cv.cvtColor(image, cv.COLOR_BGR2RGB)
        #image size
        h, w, d = image.shape
        #convert to qtImage type
        image = QtGui.QImage(image.data, w, h, w*d, QtGui.QImage.Format_RGB888)
        #scale image to correct dims and return
        return image.scaled(self.imageWidth, self.imageHeight)
    

    #------ARDUINO COMMANDS
    #Message arduino over serial
    def messageArduino(self, command : int, data : int = 0, expectReplyLen : int = 0, replyTimeOut_s : float = 5.0) -> bytearray:
        #inform of error, ret 0 if arduino not connected
        if not self.arduinoConnected:
            self.TerminalScroller.append(f"Failed To Send Arduino Message: Connection Not Established")
            return 0
        #Arduino connected...
        #clear any data in current serial buffers
        self.ardSerial.read_all()
        self.ardSerial.flush()
        #combine command byte and data into into serial of bytes
        message = bytearray()
        message.extend(command.to_bytes(4, 'little', signed = True))
        message.extend(data.to_bytes(4, 'little', signed = True))
        if DEBUG:
            self.TerminalScroller.append(f"Message Sent: {list(message)}")
        self.ardSerial.write(message)
        ret = []
        #Gather reply if expecting
        self.ardSerial.timeout = replyTimeOut_s
        if expectReplyLen:
            time.sleep(0.1)
            ret = self.ardSerial.read(4)
            self.TerminalScroller.append(f"Message Back: {list(ret)}")
        #return bytes of return value, or None if none
        return bytearray(ret)

    #send fire projectile command to arduino
    def fireProjectile(self):
        ###...
        #Need to create full firing calculator, should
        #request ir distance, waiting for reply
        #calculate trigonmetry
        #calculate drag
        #move upwards in accordance to drag, trig, etc to hit currently facing target
        #fire projectile
        self.messageArduino(AC.COMMAND_FIRE, 6, 4)

    #send motor x movement command to arduino
    def moveMotorX(self, angle):
        if FLIP_X_MOTION:
            angle = angle * -1
        ret = self.messageArduino(AC.COMMAND_MOVE_X, int(angle / AC.DEG_DECIMAL_SHIFT), 4)

    def moveMotorY(self, angle):
        if FLIP_Y_MOTION:
            angle = angle * -1
        ret = self.messageArduino(AC.COMMAND_MOVE_Y, int(angle / AC.DEG_DECIMAL_SHIFT), 4)

    #Called upon each new image when tracking is enabled
    def track(self):
        #Set tracking in motion to say function is occupied
        self.trackingInMotion = True
        #only move if angle is big enough to stop constant tiny adjustments
        xyAngles = self.cameraThread.getChestAngles()
        if xyAngles[0] > self.xMinAngle:
            self.moveMotorX(xyAngles[0])
        if xyAngles[1] > self.yMinAngle:
            self.moveMotorY(xyAngles[1])
        #Turn off tracking in motion to allow next track command
        self.trackingInMotion = False



#Class for handling camera operation in alt thread
class ImagingThread(QThread):
    #Static class variables
    frame_signal = Signal(QImage)
    heavyModel = False
    cameraFovX = 59.34
    cameraFovY = 56.5
    imageWidth = 1920
    imageHeight = 1080
    imageWidthResized = 640
    imageHeightResized = 480

    def run(self):
        self.results = None
        #connect camera
        self.cam = cv.VideoCapture(MyApp.settingsDict['CameraNum'], cv.CAP_DSHOW)
        self.cam.set(cv.CAP_PROP_FRAME_WIDTH, ImagingThread.imageWidth)
        self.cam.set(cv.CAP_PROP_FRAME_HEIGHT, ImagingThread.imageHeight)
        #Run camera whilst flag active
        while MyApp.runCamera:
            ret, rawFrame = self.cam.read()
            if not ret:
                MyApp.runCamera = False
                print(f"Failed to read camera Image! ")
                break
            self.results, frame = detector.detectAndDraw(rawFrame)
            frame = self.cvToLabel(frame)
            #This emits a signal to the application containing the image
            self.frame_signal.emit(frame)
        #upon exit, disconnect camera
        self.cam.release()
    
    #Convert cv np image to qt label image type
    def cvToLabel(self,image):
        image = cv.resize(image, (self.imageWidthResized, self.imageHeightResized))
        image = cv.cvtColor(image, cv.COLOR_BGR2RGB)
        image = QImage(image,
                       image.shape[1],
                       image.shape[0],
                       3 * image.shape[1],
                       QImage.Format_RGB888)
        return image
    
    #Obtain raw results from last image (these are normed pixels)
    def getResults(self):
        return self.results
    
    #obtain chest angle from last image
    def getChestAngles(self):
        if self.results is not None:
            return self.normedToAngle(detector.getChestResults(self.results))
        else:
            return np.array([0,0])
    
    @classmethod
    def normedToPx(cls, xyNormed) -> np.ndarray:
        imgSize = np.array([cls.imageWidthResized, cls.imageHeightResized])
        centerChestPx = xyNormed * imgSize
        return centerChestPx

    @classmethod
    def pxToAngle(cls, xyPx) -> np.ndarray:
        DPPX = cls.cameraFovX / cls.imageWidthResized
        DPPY = cls.cameraFovY / cls.imageHeightResized
        xPxFromCenter = xyPx[0] - (cls.imageWidthResized/2)
        yPxFromCenter = xyPx[1] - (cls.imageHeightResized/2)
        xDegFromCenter = xPxFromCenter * DPPX
        yDegFromCenter = yPxFromCenter * DPPY
        return np.array([xDegFromCenter, yDegFromCenter])
        
    @classmethod
    def normedToAngle(cls, xyNormed) -> np.ndarray:
        xyPx = cls.normedToPx(xyNormed)
        xyAngles = cls.pxToAngle(xyPx)
        return xyAngles


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication([])
    ui = MyApp()
    sys.exit(app.exec_())
